<!DOCTYPE html>
<!--
  The template is from Eliza Weisman,
  see http://elizas.website
-->
<html>
  <head>
    <meta name="viewport" content="width=720, initial-scale=1, maximum-scale=1">
    <link rel="icon" type="image/png" href="/favicon.png">
    <meta charset="utf-8">
    <title>Writeup for phase 2</title>
    <meta name="viewport" content="width=device-width">

    <!-- syntax highlighting CSS -->
    <link rel="stylesheet" href="/css/syntax.css">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/main.css">

  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-116308654-1"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'UA-116308654-1');
  </script>
  </head>
  <body>
    <div class="site">

      <div class = "content">
        <main>
      <!-- begin subtemplate -->
            
        <div class="textheader">
          <h1 class="title">
      
      
        Writeup for phase 2
      
          </h1>
      
        </div>
        <div class="content">
<main>
  <!-- begin content -->
  <h2 id="0-overview">0. Overview</h2>

<p>I have to admit that I have some problems with phase 2, mostly because I am not familiar with multithread programming and Cryptography. Also, I have much coursework and research assignment to do, so time is very limited. I have implemented most part of the server, tried to show a good taste in my code. I hope you wouldn’t think that’s a over-engineering.</p>

<h2 id="1-things-that-i-have-implemented">1. Things that I have implemented</h2>

<ul>
  <li>
    <ol>
      <li>A web server configured using command line args which can receive packets,</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>a log tool which can write error logs to file without blocking the main thread, I choose to use a daemon thread. It has an advantage and a disadvantage as far as I know:
        <ul>
          <li>pro: the server only need to create one thread for logging, not as many as the number of errors,</li>
          <li>con: when the server quit abruptly, the daemon thread will quit immediately as well, which will lead to potential log loss, but since the serve is supposed to run for a long time, this will be a rare scenario, so I think it will not matter a lot.
            <ul>
              <li>While writing this writeup, I just realize that my design is not good, because the log values when something happens, e.g. a malicious packet makes the server crash, but using a daemon thread will lead to log loss in this scenario, which is very bad.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<h2 id="2-things-that-i-have-not-implemented">2. Things that I have not implemented</h2>

<p>I met some problems and I didn’t solve all of them in my limited time…</p>

<ul>
  <li>
    <ol>
      <li>The server cannot check if the signature is correct. Actually I know to do it (see snippet 1 &amp; 2 below), but I cannot import the raw RSA key into Python (see snippet 1), which is very very annoying.</li>
    </ol>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># snippet 1</span>
<span class="k">def</span> <span class="nf">load_pubkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys_dict</span><span class="p">):</span>
    <span class="s">"""
    Args:
        keys_dict: (packet id, raw binary public key)
    Returns:
        (packet id, RSA public key obj)
    """</span>
    <span class="s">""" 
    ** Not implemented: **
        Failed to import RSA public key
    """</span>
    <span class="k">for</span> <span class="n">pkt_id</span> <span class="ow">in</span> <span class="n">keys_dict</span><span class="p">:</span>
        <span class="c"># keys_dict[pkt_id] = RSA.importKey(pkt_id) # Not working!!!</span>
        <span class="k">pass</span>
    <span class="k">return</span> <span class="n">keys_dict</span>
</code></pre></div>    </div>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># snippet 2</span>
<span class="k">def</span> <span class="nf">signature_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pkt_id</span><span class="p">,</span> <span class="n">pkt_seq_num</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">pubkey</span><span class="p">):</span>
    <span class="s">"""
        Return true if the signatrue is valid
        ** Not fully implemented: ** 
            because failed to import RSA key from file, see utils.load_pubkeys()
    """</span>
    <span class="s">"""
    # The code should be like this:
    expected_hash = pubkey.decrypt(signature)
    received_hash = sha256(content).hexdigest()
    if expected_hash != received_hash:
        self.verify_log_queue.put( # put the error log into queue
            "</span><span class="si">%</span><span class="s">s</span><span class="se">\n</span><span class="si">%</span><span class="s">s</span><span class="se">\n</span><span class="si">%</span><span class="s">s</span><span class="se">\n</span><span class="si">%</span><span class="s">s" </span><span class="si">% </span><span class="s">
            (self.utils.bytes_2_hex_str(pkt_id),
            self.utils.bytes_2_dec_str(pkt_seq_num),
            received_hash,
            expected_hash)
        )
        return False
    else:
        return True
</span></code></pre></div>    </div>
  </li>
  <li>
    <ol>
      <li>The server cannot check if the checksum is correct because I am not sure how to calculate it. I have implemented a prototype of how I am going to do when I know it.</li>
    </ol>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">checksum_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pkt_id</span><span class="p">,</span> <span class="n">pkt_seq_num</span><span class="p">,</span> <span class="n">pkt_checksum_idx</span><span class="p">):</span>
    <span class="s">"""
        Return true if the checksums match
        ** Not fully implemented: **
            because haven't figured out how checksum works in this scenario
    """</span>
    <span class="c"># The code should be like this:</span>
    <span class="n">received_crc32</span> <span class="o">=</span> <span class="s">"I don't know how to calulate it"</span>
    <span class="n">expected_crc32</span> <span class="o">=</span> <span class="s">"I don't know how to calulate it as well"</span>
    <span class="k">if</span> <span class="n">received_crc32</span> <span class="o">!=</span> <span class="n">expected_crc32</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">checksum_log_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span>
            <span class="s">"</span><span class="si">%</span><span class="s">s</span><span class="se">\n</span><span class="si">%</span><span class="s">s</span><span class="se">\n</span><span class="si">%</span><span class="s">s</span><span class="se">\n</span><span class="si">%</span><span class="s">s</span><span class="se">\n</span><span class="si">%</span><span class="s">s</span><span class="se">\n</span><span class="s">"</span> <span class="o">%</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">bytes_2_hex_str</span><span class="p">(</span><span class="n">pkt_id</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">bytes_2_dec_str</span><span class="p">(</span><span class="n">pkt_seq_num</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">bytes_2_dec_str</span><span class="p">(</span><span class="n">pkt_checksum_idx</span><span class="p">),</span>
            <span class="n">received_crc32</span><span class="p">,</span>
            <span class="n">expected_crc32</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li>
    <ol>
      <li>I didn’t have time to figure out how to use the XOR cipher, all I know about XOR is approximately <code class="highlighter-rouge">a ^ b ^ b = a</code>.</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>As I didn’t implemented the features above, the server didn’t use the adorable cat as well.</li>
    </ol>
  </li>
</ul>


  <!-- end content -->
  </main>
</div>
      <!-- end subtemplate -->
      </main>
      </div>
      </div>

    </div>
  </body>
</html>
