# A demo to test parsing JSON string

## Overview

Right now, I am using the [cJSON](https://github.com/DaveGamble/cJSON) (repo size = 4.5 Mb), which is a parser for JSON. Now I have created a small demo for test a internal function called `parse_string()`.

## Progress

The workflow of the demo is:

* 1. **Manually add some logs using `fopen()` around platform-independent operations (e.g. relavent constants) in the source code, such as:**
  ```c
    while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
    {
      /* it's a log */ log_parse_string = fopen("parse_string: *input_end != \'\"\'", "w");
      /* is escape sequence */
      if (input_end[0] == '\\')
      {
        /* it's a log */ log_parse_string = fopen("parse_string: input_end[0] == \'\\\'", "w");
        if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
        {
          /* prevent buffer overflow when last input character is a backslash */
          goto fail;
        }
        skipped_bytes++;
        input_end++;
      }
      input_end++;
    }
    if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))
    {
      /* it's a log */ log_parse_string = fopen("parse_string: *input_end != \'\"\'", "w");
      goto fail; /* string ended unexpectedly */
    }
  ```
* 2. **Create test cases, when creating it, I will first try to cover every predicate in the source code, except special situation (e.g. Out Of Memory), then I will come up with some random inputs, just to make our test cases more robust.**

* 3. **Run a test program using these test cases with `strace`, and I will get logs like:**
  ```plaintext
  execve("./a.out", ["./a.out", "{\"I\": \"say,\"}"], [/* 72 vars */]) = 0
  ...
  close(3)                                = 0
  access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
  open("/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
  ...
  open("parse_object_start", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 3
  open("parse_string: start", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 4
  open("parse_string: input_buffer)[0] != '\"'", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 5
  open("parse_string: *input_end != '\"'", O_WRONLY|O_CREAT|O_TRUNC, 0666) = 6
  ...
  fstat(1, {st_mode=S_IFIFO|0600, st_size=0, ...}) = 0
  write(1, "{\n\t\"I\":\t\"say,\"\n}\n", 17{
    "I":	"say,"
  }
  ) = 17
  exit_group(0)                           = ?
  +++ exited with 0 +++
  ```

* 4. **I wrote a Perl script to run these tests and generate logs automatically, basically these logs generated by `strace` will be stored into seperated files. Just like:**
  ```plaintext
  jiahao:~/cJSON ► tree parsing_test                                   (master✱) 
  parsing_test
  ├── parse_string_test_0.output
  ├── parse_string_test_1.output
  ├── parse_string_test_2.output
  ├── parse_string_test_3.output
  ├── parse_string_test_4.output
  ├── parse_string_test_5.output
  ├── parse_string_test_6.output
  ├── parse_string_test_7.output
  ├── parse_string_test_8.output
  └── parse_string_test_9.output

  0 directories, 10 files
  ```

## TODO:

* I need to use regex to trim the logs so that it only contains the contents we want;
* I need to think more about the placement of these logs, especially when there is a loop.
* I need to come up with more test cases for this function. (Maybe 50?)
* I need to test other functions with the similar way, e.g. `parse_object()`, `parse_array`.

## Outcome

Some JSON string test cases:

```JSON
  {"normal": "whatever"}',
  '{"empty": ""}', 
  '{"not correctly quoted: "whatever"}', 
  '{"escapes": "\n\r\t\b\f\"\\\\\/\u"}', # By now, most predicates of the function has been covered
  '{"numerical": "123.456"}', # Some random strings
  '{"I": "say,"}', 
  '{"\"Perl": "is"}', 
  '{"very": "convenient"}', 
  '{"in": "such"}', 
  '{"scenario": "right?\""}', 
  '{"Yeah!": "It\'s tota11y: r$ght"}
```

[The function that I have annotated](./annotated.c)

The auto-generated logs:   
[parse_string_test_0.output](./parsing_test/parse_string_test_0.output)  
[parse_string_test_1.output](./parsing_test/parse_string_test_1.output)  
[parse_string_test_2.output](./parsing_test/parse_string_test_2.output)  
[parse_string_test_3.output](./parsing_test/parse_string_test_3.output)  
[parse_string_test_4.output](./parsing_test/parse_string_test_4.output)  
[parse_string_test_5.output](./parsing_test/parse_string_test_5.output)  
[parse_string_test_6.output](./parsing_test/parse_string_test_6.output)  
[parse_string_test_7.output](./parsing_test/parse_string_test_7.output)  
[parse_string_test_8.output](./parsing_test/parse_string_test_8.output)  
[parse_string_test_9.output](./parsing_test/parse_string_test_9.output)  

The Perl script:

```Perl
#!/usr/bin/perl
sub say {print @_, "\n"}
$dir = "parsing_test";
$mkdir = `mkdir -p $dir`;

@parse_string_test = 
('{"normal": "whatever"}',
'{"empty": ""}', 
'{"not correctly quoted: "whatever"}', 
'{"escapes": "\n\r\t\b\f\"\\\\\/\u"}', # By now, most predicates of the function has been covered
'{"numerical": "123.456"}', 
'{"I": "say,"}', 
'{"\"Perl": "is"}', 
'{"very": "convenient"}', 
'{"in": "such"}', 
'{"scenario": "right?\""}', 
'{"Yeah!": "It\'s tota11y: r$ght"}');

say "*****Here comes the strings for test parse_string():*****";
for ( $i = 0; $i < @parse_string_test; $i = $i + 1 ) {
  say $parse_string_test[$i];
  $filename = "$dir/parse_string_test_$i.output";
  $output = `strace ./a.out '$parse_string_test[$i]' 2>&1 | tee $filename`;
}
say "---------------------------------------------------------------------------";
```
