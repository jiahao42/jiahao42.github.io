---
layout: post
title: Recursion and iteration
pwd: posts
cmd: cat Recursion and iteration
date: Aug 20, 2018
tags: SICP
---

<img src="../imgs/sicp-cover.png" alt="sicp-cover" style="height: 250px;"/>

This article will be short because I will only talk one thing here, the technique of converting between recursion and iteration. After reading 80 pages of SICP, I think it's neccessary to write it down, it's hard to imagine I used to do it intuitively and have never thought it through before, 


```Lisp
(define (factorial n)
  (if (= n 1)
    1
    (* n (factorial (- n 1)))))
```

Take the Factorial as an simple example, when we use a recursion program (the code above) to calculate it, someone who knows a little about programming will know what the call stack looks like:

```Lisp
(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
(* 6 (* 5 (* 4 (factorial 3))))
(* 6 (* 5 (* 4 (* 3 (factorial 2)))))
(* 6 (* 5 (* 4 (* 3 (* 2 (factorial 1))))))
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
(* 6 (* 5 (* 4 6)))
(* 6 (* 5 24))
(* 6 120)
720
```

Now think about a question, what do you think is the key feature to support the recursion above?

I will say it's the ability to create call stacks (which can store arguments and local variables). In `(* n (factorial (- n 1)))`, we have to store the left operand `n` until the right operand `(factorial (- n 1))` returns. In other words, the variables will be stored on its stack.

Think about iteration

这样思考之后，递归的本质就明显了，我认为递归的本质就是迭代，不同之处在于，递归利用程序内部的堆栈来存储中间变量，而迭代使用参数来存储中间变量。如果想要将一段递归程序转换为一段迭代程序，只需增加几个参数即可，参数的个数取决于这段程序需要的中间变量的个数。

如此一来，计算阶乘的递归程序可以改写为以下的迭代程序：

```Lisp
(define (factorial n)
  (define (fact-iter product counter max-count)
    (if (> counter max-count)
      product
      (fact-iter (* counter product)
                 (+ counter 1)
                 max-count)))
  (fact-iter 1 1 n))
```

除了递归程序中原有的参数`n`以外，这里又加上了`product`与`counter`参数，发现了吗？其实`product`与`counter`两个参数所扮演的角色就是堆栈在递归程序中所扮演的角色。所以递归程序如何变成迭代程序呢？加参数就可以了。

递归与迭代，一个用堆栈记录信息，一个用参数记录信息，仅此而已。


(The End)


<!--

                            fib 5
                        /           \
                      /               \
                    /                   \
                  /                       \
                /                           \
             fib 4                        fib 3
           /        \                     /    \
          /          \                   /      \
         /            \                fib 2    fib 1
        /              \               /   \      |    
      fib 3           fib 2           /     \     |    
      /    \          /   \         fib 1  fib 0  1      
     /      \        /     \          |      |            
   fib 2    fib 1  fib 1  fib 0       |      |             
   /   \      |      |      |         1      0           
  /     \     |      |      |                 
fib 1  fib 0  1      1      0                     
  |      |      
  |      |      
  1      0  
-->